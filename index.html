<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Title:ONIGIRI コイン</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    body { font-family: "Noto Sans JP", sans-serif; margin: 0; padding: 0; background-color: #f8f8f8; text-align: center; color: #333; }
    header { background-color: #2c3e50; color: white; padding: 15px 0; font-size: 1.5em; }
    main { width: 80%; max-width: 800px; margin: 20px auto; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); }
    img { max-width: 200px; height: auto; margin: 20px; }
    .info { font-size: 1.2em; margin: 10px 0; }
    footer { background-color: #2c3e50; color: white; padding: 10px 0; margin-top: 20px; }
    .vote-container { display: flex; justify-content: center; align-items: center; margin-top: 20px; gap: 24px; flex-wrap: wrap; }
    .vote-item { margin: 0 20px; text-align: center; }
    .vote-button { margin-top: 10px; padding: 10px 20px; font-size: 1em; cursor: pointer; border: none; background-color: #3498db; color: white; border-radius: 10px; transition: background 0.3s; }
    .vote-button:hover { background-color: #2980b9; }
    .wp-link { margin-top: 30px; font-size: 1.2em; }
    .additional-links { margin-top: 20px; text-align: left; display: inline-block; }
    .additional-links a { color: #007BFF; text-decoration: none; font-size: 1em; }
    .additional-links a:hover { text-decoration: underline; }
    .muted { opacity: .75; font-size: .95em; }
    .tiny { opacity: .65; font-size: .85em; }
  </style>
</head>
<body>
  <header>
    <h1> ONIGIRI コイン （GRI）</h1>
  </header>
  <main>
    <img src="onigiri2.png" alt="ONIGIRI コイン" />
    <p class="info"><strong>発行量:</strong> 22m</p>
    <p class="info"><strong>どんな味がお好みですか？ / What flavor do you prefer?</strong></p>

    <div class="vote-container">
      <div class="vote-item">
        <img src="syake.webp" alt="鮭" />
        <button class="vote-button" onclick="vote('syake')">投票する / Vote</button>
        <div>投票数: <span id="syakeCount">0</span></div>
      </div>
      <div class="vote-item">
        <img src="ume.webp" alt="梅干し" />
        <button class="vote-button" onclick="vote('ume')">投票する / Vote</button>
        <div>投票数: <span id="umeCount">0</span></div>
      </div>
    </div>

    <button id="connectWallet" class="vote-button">ウォレットを接続 / Connect Wallet</button>
    <p id="walletAddress">ウォレット未接続 / Wallet not connected</p>
    <p id="griBalance">GRI 残高: -</p>
    <p id="hint" class="muted" style="display:none"></p>
    <p id="mintInfo" class="tiny" style="display:none"></p>

    <div class="wp-link">
      <a href="wp.html" target="_blank">ホワイトペーパーはこちら / View the Whitepaper</a>
    </div>

    <div class="additional-links">
      <p><strong>Solscan:</strong> <a href="https://solscan.io/token/Va7yuUnSYdg23QjHjPAc9fkBrK3oD4mr3Ee52vFcyev" target="_blank">GRI トークン情報</a></p>
      <p><strong>取引所 / Exchanges:</strong></p>
      <ul>
        <li><a href="https://photon-sol.tinyastro.io/en/lp/2WBSLsjagCt3BLncpwBrprFF5uhFz8WbdrpvGvueZ8tz" target="_blank">Photon SOL</a></li>
        <li><a href="https://www.geckoterminal.com/solana/pools/2WBSLsjagCt3BLncpwBrprFF5uhFz8WbdrpvGvueZ8tz" target="_blank">GeckoTerminal</a></li>
      </ul>
    </div>
  </main>
  <footer>
    <p>&copy; 2025 ONIGIRI Coin. All Rights Reserved.</p>
  </footer>

  <!-- 先に web3.js を読み込む -->
  <script src="https://unpkg.com/@solana/web3.js@1.30.0/lib/index.iife.min.js"></script>

  <script>
    (function() {
      // ====== 設定 ======
      const MINT = "Va7yuUnSYdg23QjHjPAc9fkBrK3oD4mr3Ee52vFcyev"; // GRI mint
      const RPC_URLS = [
        "https://api.mainnet-beta.solana.com",
        // 予備（公開RPC。可用性確保用。必要に応じて並びを調整）
        "https://rpc.ankr.com/solana",
        "https://solana-api.projectserum.com"
      ];

      const els = {
        connectBtn: null,
        addr: null,
        balance: null,
        hint: null,
        syakeCount: null,
        umeCount: null,
        mintInfo: null,
      };

      // ====== Phantom 優先 ======
      function getPhantomProvider() {
        console.log('=== Phantom検出開始 ===');
        console.log('window.phantom:', window.phantom);
        console.log('window.solana:', window.solana);
        console.log('window.phantom?.solana:', window.phantom?.solana);

        // 方法1: window.phantom.solana (推奨)
        if ('phantom' in window) {
          const phantomProvider = window.phantom?.solana;
          console.log('window.phantom.solana found:', phantomProvider);
          if (phantomProvider?.isPhantom) {
            console.log('✓ Phantomプロバイダー検出成功 (window.phantom.solana)');
            console.log('Provider details:', {
              isPhantom: phantomProvider.isPhantom,
              publicKey: phantomProvider.publicKey?.toString(),
              isConnected: phantomProvider.isConnected
            });
            return phantomProvider;
          }
        }

        // 方法2: window.solana
        if ('solana' in window) {
          const provider = window.solana;
          console.log('window.solana found:', provider);
          console.log('window.solana.isPhantom:', provider?.isPhantom);

          if (provider?.isPhantom) {
            console.log('✓ Phantomプロバイダー検出成功 (window.solana)');
            return provider;
          }

          // providers配列から探す
          if (provider?.providers?.length) {
            console.log('複数のプロバイダーが見つかりました:', provider.providers.length);
            const phantom = provider.providers.find((p) => p?.isPhantom);
            if (phantom) {
              console.log('✓ Phantomプロバイダー検出成功 (providers配列)');
              return phantom;
            }
          }
        }

        console.log('✗ Phantomプロバイダーが見つかりませんでした');
        return null;
      }

      // Phantomプロバイダーが利用可能になるまで待機
      async function waitForPhantom(maxAttempts = 10) {
        for (let i = 0; i < maxAttempts; i++) {
          const provider = getPhantomProvider();
          if (provider) return provider;
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        return null;
      }

      // タイムアウト付きPromise
      function withTimeout(promise, ms, errorMsg) {
        return Promise.race([
          promise,
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error(errorMsg)), ms)
          )
        ]);
      }

      async function connectPhantom() {
        // Phantomが読み込まれるまで待つ
        console.log('=== connectPhantom 開始 ===');
        const provider = await waitForPhantom();

        if (!provider) {
          console.error('Phantomプロバイダーが見つかりません');
          alert('Phantom 拡張が見つかりません。\nPhantomをインストールして、ページを再読み込みしてください。\n\nPhantom wallet extension not found.\nPlease install Phantom and reload the page.');
          window.open('https://phantom.app/', '_blank');
          return null;
        }

        console.log('✓ Phantomプロバイダー取得成功');
        console.log('Provider type:', typeof provider);
        console.log('Provider.connect type:', typeof provider.connect);
        console.log('Provider.isConnected:', provider.isConnected);
        console.log('Provider.publicKey:', provider.publicKey?.toString());

        try {
          console.log('provider.connect() を呼び出します...');
          console.log('これからPhantomの接続確認ポップアップが表示されるはずです');

          // 30秒のタイムアウトを設定
          const connectPromise = provider.connect();
          console.log('connect() Promise created:', connectPromise);

          const resp = await withTimeout(
            connectPromise,
            30000,
            'ウォレット接続がタイムアウトしました'
          );

          console.log('connect() レスポンス:', resp);
          console.log('resp.publicKey:', resp?.publicKey);

          const pubkey = resp.publicKey.toString();
          console.log('✓ 接続成功! Public Key:', pubkey);
          return { provider, pubkey };
        } catch (error) {
          console.error('=== 接続エラー発生 ===');
          console.error('エラーオブジェクト:', error);
          console.error('エラーメッセージ:', error?.message);
          console.error('エラーコード:', error?.code);
          console.error('エラースタック:', error?.stack);

          if (error.code === 4001) {
            // ユーザーがリクエストを拒否
            console.log('ユーザーが接続をキャンセルしました');
            alert('接続がキャンセルされました。\nConnection cancelled.');
          } else if (error.message?.includes('timeout') || error.message?.includes('タイムアウト')) {
            console.log('接続がタイムアウトしました');
            alert('ウォレット接続がタイムアウトしました。\nPhantomウォレットが起動しているか確認して、再度お試しください。\n\nConnection timeout.\nPlease make sure Phantom wallet is running and try again.');
          } else if (error.message?.includes('Network request failed')) {
            console.log('ネットワークリクエストエラー');
            alert('ネットワークエラーが発生しました。\n\n考えられる原因：\n• Phantomの接続確認ポップアップが表示されましたか？\n• ブラウザのポップアップブロックを確認してください\n• Phantomウォレットを再起動してください\n• ブラウザを再読み込みしてください\n\nNetwork request failed.\nPlease check if Phantom popup was blocked and try again.');
          } else {
            console.log('予期しないエラー');
            throw error;
          }
          return null;
        }
      }

      // ====== ユーティリティ ======
      function updateVoteUI() {
        els.syakeCount.textContent = String(Number(localStorage.getItem('vote_syake') || '0'));
        els.umeCount.textContent = String(Number(localStorage.getItem('vote_ume') || '0'));
      }

      window.vote = function(kind) {
        const key = kind === 'syake' ? 'vote_syake' : 'vote_ume';
        const next = (Number(localStorage.getItem(key) || '0') + 1);
        localStorage.setItem(key, String(next));
        updateVoteUI();
      };

      async function withRPCs(fn) {
        let lastErr = null;
        for (const url of RPC_URLS) {
          try {
            if (typeof solanaWeb3 === 'undefined') throw new Error('solanaWeb3 未ロード');
            const c = new solanaWeb3.Connection(url, 'confirmed');

            // 軽く ping（10秒タイムアウト）
            await withTimeout(c.getEpochInfo(), 10000, 'RPC ping タイムアウト');

            // 実際の処理（30秒タイムアウト）
            return await withTimeout(fn(c), 30000, 'RPC処理タイムアウト');
          } catch (e) {
            lastErr = e;
            console.warn('RPC失敗をスキップ:', url, e?.message || e);
          }
        }
        throw lastErr || new Error('全てのRPCに失敗');
      }

      function programIdLabel(pid) {
        const s = String(pid);
        if (s === 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') return 'SPL Token (legacy)';
        if (s === 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb') return 'Token-2022 (extensions)';
        return s;
      }

      // ====== 残高取得（mintフィルタ優先） ======
      async function fetchGRIBalance(ownerBase58) {
        try {
          els.balance.textContent = 'GRI 残高: 読み込み中... / Loading...';

          const owner = new solanaWeb3.PublicKey(ownerBase58);

          const { amountStr, found, program } = await withRPCs(async (conn) => {
            // 1) mint で直接フィルタ（最もシンプル & プログラム差異に強い）
            const parsedByMint = await conn.getParsedTokenAccountsByOwner(owner, { mint: new solanaWeb3.PublicKey(MINT) });
            if (parsedByMint.value?.length) {
              const info = parsedByMint.value[0].account.data.parsed.info;
              const tok = info.tokenAmount;
              const amt = tok.uiAmountString ?? (typeof tok.uiAmount === 'number' ? String(tok.uiAmount) : '0');
              return { amountStr: amt, found: true, program: info.owner || 'unknown' };
            }

            // 2) 念のため programId で両方試す
            const PROGRAM_IDS = [
              'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
              'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'
            ];
            for (const pid of PROGRAM_IDS) {
              const res = await conn.getParsedTokenAccountsByOwner(owner, { programId: new solanaWeb3.PublicKey(pid) });
              for (const entry of res.value) {
                const info = entry.account.data.parsed.info;
                if (info.mint === MINT) {
                  const tok = info.tokenAmount;
                  const amt = tok.uiAmountString ?? (typeof tok.uiAmount === 'number' ? String(tok.uiAmount) : '0');
                  return { amountStr: amt, found: true, program: pid };
                }
              }
            }

            // 3) 見つからない（ATA未作成 or 残高0）
            return { amountStr: '0', found: false, program: null };
          });

          els.balance.textContent = `GRI 残高: ${amountStr} GRI`;
          if (!found) {
            els.hint.style.display = 'block';
            els.hint.textContent = 'GRI のトークン口座が見つかりません（初受取前=ATA未作成の可能性）';
          }

          // Mint の owner (= どのトークンプログラムか) も表示
          try {
            const mintOwner = await withRPCs(async (conn) => {
              const acc = await conn.getAccountInfo(new solanaWeb3.PublicKey(MINT));
              return acc?.owner?.toBase58?.() || String(acc?.owner || '');
            });
            if (mintOwner) {
              els.mintInfo.style.display = 'block';
              els.mintInfo.textContent = `Mint Program: ${programIdLabel(mintOwner)}`;
            }
          } catch {}
        } catch (error) {
          console.error('残高取得エラー:', error);
          els.balance.textContent = 'GRI 残高: 取得失敗 / Failed to load';
          els.hint.style.display = 'block';
          els.hint.textContent = '残高の取得に失敗しました。ネットワーク接続を確認してください。 / Failed to fetch balance. Please check your network connection.';
        }
      }

      // ====== 自動接続 ======
      async function tryAutoConnect() {
        try {
          console.log('自動接続を試みています...');
          const provider = await waitForPhantom();
          if (!provider) {
            console.log('Phantomプロバイダーが見つかりません');
            return;
          }

          // 既に接続済みの場合は自動接続（タイムアウト10秒）
          const resp = await withTimeout(
            provider.connect({ onlyIfTrusted: true }),
            10000,
            '自動接続タイムアウト'
          );

          if (resp?.publicKey) {
            const pubkey = resp.publicKey.toString();
            console.log('自動接続成功:', pubkey);

            // UIを更新
            els.connectBtn.textContent = '接続済み / Connected';
            els.connectBtn.style.backgroundColor = '#27ae60';
            els.connectBtn.disabled = true;
            els.addr.textContent = `ウォレット: ${pubkey.substring(0, 4)}...${pubkey.substring(pubkey.length - 4)}`;

            // 残高を非同期で取得
            fetchGRIBalance(pubkey).catch(err => {
              console.error('自動接続後の残高取得に失敗:', err);
            });

            // イベントリスナーを設定
            provider?.on?.('accountChanged', (publicKey) => {
              if (publicKey) {
                console.log('Account changed:', publicKey.toString());
                location.reload();
              } else {
                console.log('Account disconnected');
                location.reload();
              }
            });
            provider?.on?.('disconnect', () => {
              console.log('Wallet disconnected');
              location.reload();
            });
          }
        } catch (e) {
          // 自動接続失敗は無視（ユーザーが手動で接続できる）
          // タイムアウトや信頼されていない場合は正常な動作
          if (e?.message?.includes('タイムアウト') || e?.code === 4001) {
            console.log('自動接続スキップ（手動接続が必要）');
          } else {
            console.log('自動接続失敗:', e?.message || e);
          }
        }
      }

      // ====== 初期化 ======
      function bind() {
        els.connectBtn = document.getElementById('connectWallet');
        els.addr = document.getElementById('walletAddress');
        els.balance = document.getElementById('griBalance');
        els.hint = document.getElementById('hint');
        els.syakeCount = document.getElementById('syakeCount');
        els.umeCount = document.getElementById('umeCount');
        els.mintInfo = document.getElementById('mintInfo');

        updateVoteUI();

        // ページロード時に自動接続を試みる
        tryAutoConnect();
        els.connectBtn?.addEventListener('click', async () => {
          // ボタンを無効化して二重クリックを防止
          els.connectBtn.disabled = true;
          els.connectBtn.textContent = '接続中... / Connecting...';

          try {
            const conn = await connectPhantom();
            if (!conn) {
              els.connectBtn.disabled = false;
              els.connectBtn.textContent = 'ウォレットを接続 / Connect Wallet';
              return;
            }

            const { provider, pubkey } = conn;

            // ウォレット接続成功 - すぐにUIを更新
            els.connectBtn.textContent = '接続済み / Connected';
            els.connectBtn.style.backgroundColor = '#27ae60';
            els.addr.textContent = `ウォレット: ${pubkey.substring(0, 4)}...${pubkey.substring(pubkey.length - 4)}`;
            els.hint.style.display = 'block';
            els.hint.textContent = '残高読取は複数RPCでフェイルオーバーします（ウォレット側ネットワークは不問）';

            // 残高を非同期で取得（失敗しても接続は維持）
            fetchGRIBalance(pubkey).catch(err => {
              console.error('残高取得に失敗しましたが、ウォレットは接続されています:', err);
            });

            // ウォレットイベントのリスナーを設定
            provider?.on?.('accountChanged', (publicKey) => {
              if (publicKey) {
                console.log('Account changed to:', publicKey.toString());
                location.reload();
              } else {
                console.log('Account disconnected');
                location.reload();
              }
            });

            provider?.on?.('disconnect', () => {
              console.log('Wallet disconnected');
              location.reload();
            });
          } catch (e) {
            console.error('connect failed', e);
            alert(`ウォレット接続に失敗しました:\n${e?.message || e}\n\nWallet connection failed:\n${e?.message || e}`);
            els.connectBtn.disabled = false;
            els.connectBtn.textContent = 'ウォレットを接続 / Connect Wallet';
          }
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', bind);
      } else { bind(); }
    })();
  </script>
</body>
</html>



