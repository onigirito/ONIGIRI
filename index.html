<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Title:ONIGIRI コイン</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    body { font-family: "Noto Sans JP", sans-serif; margin: 0; padding: 0; background-color: #f8f8f8; text-align: center; color: #333; }
    header { background-color: #2c3e50; color: white; padding: 15px 0; font-size: 1.5em; }
    main { width: 80%; max-width: 800px; margin: 20px auto; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); }
    img { max-width: 200px; height: auto; margin: 20px; }
    .info { font-size: 1.2em; margin: 10px 0; }
    footer { background-color: #2c3e50; color: white; padding: 10px 0; margin-top: 20px; }
    .vote-container { display: flex; justify-content: center; align-items: center; margin-top: 20px; gap: 24px; flex-wrap: wrap; }
    .vote-item { margin: 0 20px; text-align: center; }
    .vote-button { margin-top: 10px; padding: 10px 20px; font-size: 1em; cursor: pointer; border: none; background-color: #3498db; color: white; border-radius: 10px; transition: background 0.3s; }
    .vote-button:hover { background-color: #2980b9; }
    .wp-link { margin-top: 30px; font-size: 1.2em; }
    .additional-links { margin-top: 20px; text-align: left; display: inline-block; }
    .additional-links a { color: #007BFF; text-decoration: none; font-size: 1em; }
    .additional-links a:hover { text-decoration: underline; }
    .muted { opacity: .75; font-size: .95em; }
    .tiny { opacity: .65; font-size: .85em; }
  </style>
</head>
<body>
  <header>
    <h1> ONIGIRI コイン （GRI）</h1>
  </header>
  <main>
    <img src="onigiri2.png" alt="ONIGIRI コイン" />
    <p class="info"><strong>発行量:</strong> 22m</p>
    <p class="info"><strong>どんな味がお好みですか？ / What flavor do you prefer?</strong></p>

    <div class="vote-container">
      <div class="vote-item">
        <img src="syake.webp" alt="鮭" />
        <button class="vote-button" onclick="vote('syake')">投票する / Vote</button>
        <div>投票数: <span id="syakeCount">0</span></div>
      </div>
      <div class="vote-item">
        <img src="ume.webp" alt="梅干し" />
        <button class="vote-button" onclick="vote('ume')">投票する / Vote</button>
        <div>投票数: <span id="umeCount">0</span></div>
      </div>
    </div>

    <button id="connectWallet" class="vote-button">ウォレットを接続 / Connect Wallet</button>
    <p id="walletAddress">ウォレット未接続 / Wallet not connected</p>
    <p id="griBalance">GRI 残高: -</p>
    <p id="hint" class="muted" style="display:none"></p>
    <p id="mintInfo" class="tiny" style="display:none"></p>

    <div class="wp-link">
      <a href="wp.html" target="_blank">ホワイトペーパーはこちら / View the Whitepaper</a>
    </div>

    <div class="additional-links">
      <p><strong>Solscan:</strong> <a href="https://solscan.io/token/Va7yuUnSYdg23QjHjPAc9fkBrK3oD4mr3Ee52vFcyev" target="_blank">GRI トークン情報</a></p>
      <p><strong>取引所 / Exchanges:</strong></p>
      <ul>
        <li><a href="https://photon-sol.tinyastro.io/en/lp/2WBSLsjagCt3BLncpwBrprFF5uhFz8WbdrpvGvueZ8tz" target="_blank">Photon SOL</a></li>
        <li><a href="https://www.geckoterminal.com/solana/pools/2WBSLsjagCt3BLncpwBrprFF5uhFz8WbdrpvGvueZ8tz" target="_blank">GeckoTerminal</a></li>
      </ul>
    </div>
  </main>
  <footer>
    <p>&copy; 2025 ONIGIRI Coin. All Rights Reserved.</p>
  </footer>

  <!-- 先に web3.js を読み込む -->
  <script src="https://unpkg.com/@solana/web3.js@1.30.0/lib/index.iife.min.js"></script>

  <script>
    (function() {
      // ====== 設定 ======
      const MINT = "Va7yuUnSYdg23QjHjPAc9fkBrK3oD4mr3Ee52vFcyev"; // GRI mint
      const RPC_URLS = [
        "https://api.mainnet-beta.solana.com",
        // 予備（公開RPC。可用性確保用。必要に応じて並びを調整）
        "https://rpc.ankr.com/solana",
        "https://solana-api.projectserum.com"
      ];

      const els = {
        connectBtn: null,
        addr: null,
        balance: null,
        hint: null,
        syakeCount: null,
        umeCount: null,
        mintInfo: null,
      };

      // ====== Phantom 優先 ======
      function getPhantomProvider() {
        const w = window;
        try {
          if (w.solana?.providers?.length) {
            const phantom = w.solana.providers.find((p) => p && p.isPhantom);
            if (phantom) {
              console.log('getPhantomProvider: found via window.solana.providers');
              return phantom;
            }
          }
          if (w.solana?.isPhantom) {
            console.log('getPhantomProvider: found via window.solana.isPhantom');
            return w.solana;
          }
          if (w.phantom?.solana?.isPhantom) {
            console.log('getPhantomProvider: found via window.phantom.solana');
            return w.phantom.solana;
          }
        } catch (e) {
          console.warn('getPhantomProvider error', e);
        }
        console.log('getPhantomProvider: Phantom not found');
        return null;
      }

      async function connectPhantom() {
        console.log('connectPhantom: start');
        const provider = getPhantomProvider();
        if (!provider) {
          alert('Phantom 拡張が見つかりません。ブラウザ拡張をインストール/有効化してください。');
          return null;
        }
        try {
          console.log('connectPhantom: calling provider.connect()');
          const res = await provider.connect({ onlyIfTrusted: false });
          console.log('connectPhantom: connect success', res);
          const pubkey = res?.publicKey?.toString?.() || provider.publicKey?.toString?.();
          console.log('connectPhantom: pubkey', pubkey);
          return { provider, pubkey };
        } catch (e) {
          console.error('connectPhantom: connect failed', e);
          // ユーザー向けの情報も更新
          try {
            const msg = e?.message || String(e);
            alert('ウォレット接続に失敗しました: ' + msg);
          } catch {}
          return null;
        }
      }

      // ====== ユーティリティ ======
      function updateVoteUI() {
        els.syakeCount.textContent = String(Number(localStorage.getItem('vote_syake') || '0'));
        els.umeCount.textContent = String(Number(localStorage.getItem('vote_ume') || '0'));
      }

      window.vote = function(kind) {
        const key = kind === 'syake' ? 'vote_syake' : 'vote_ume';
        const next = (Number(localStorage.getItem(key) || '0') + 1);
        localStorage.setItem(key, String(next));
        updateVoteUI();
      };

      async function withRPCs(fn) {
        let lastErr = null;
        for (const url of RPC_URLS) {
          try {
            if (typeof solanaWeb3 === 'undefined') throw new Error('solanaWeb3 未ロード');
            const c = new solanaWeb3.Connection(url, 'confirmed');
            // 軽く ping
            await c.getEpochInfo();
            return await fn(c);
          } catch (e) {
            lastErr = e;
            console.warn('RPC失敗をスキップ:', url, e);
          }
        }
        throw lastErr || new Error('全てのRPCに失敗');
      }

      function programIdLabel(pid) {
        const s = String(pid);
        if (s === 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') return 'SPL Token (legacy)';
        if (s === 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb') return 'Token-2022 (extensions)';
        return s;
      }

      // ====== 残高取得（mintフィルタ優先） ======
      async function fetchGRIBalance(ownerBase58) {
        const owner = new solanaWeb3.PublicKey(ownerBase58);

        const { amountStr, found, program } = await withRPCs(async (conn) => {
          // 1) mint で直接フィルタ（最もシンプル & プログラム差異に強い）
          const parsedByMint = await conn.getParsedTokenAccountsByOwner(owner, { mint: new solanaWeb3.PublicKey(MINT) });
          if (parsedByMint.value?.length) {
            const info = parsedByMint.value[0].account.data.parsed.info;
            const tok = info.tokenAmount;
            const amt = tok.uiAmountString ?? (typeof tok.uiAmount === 'number' ? String(tok.uiAmount) : '0');
            return { amountStr: amt, found: true, program: info.owner || 'unknown' };
          }

          // 2) 念のため programId で両方試す
          const PROGRAM_IDS = [
            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
            'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'
          ];
          for (const pid of PROGRAM_IDS) {
            const res = await conn.getParsedTokenAccountsByOwner(owner, { programId: new solanaWeb3.PublicKey(pid) });
            for (const entry of res.value) {
              const info = entry.account.data.parsed.info;
              if (info.mint === MINT) {
                const tok = info.tokenAmount;
                const amt = tok.uiAmountString ?? (typeof tok.uiAmount === 'number' ? String(tok.uiAmount) : '0');
                return { amountStr: amt, found: true, program: pid };
              }
            }
          }

          // 3) 見つからない（ATA未作成 or 残高0）
          return { amountStr: '0', found: false, program: null };
        });

        els.balance.textContent = `GRI 残高: ${amountStr} GRI`;
        if (!found) {
          els.hint.style.display = 'block';
          els.hint.textContent = 'GRI のトークン口座が見つかりません（初受取前=ATA未作成の可能性）';
        }

        // Mint の owner (= どのトークンプログラムか) も表示
        try {
          const mintOwner = await withRPCs(async (conn) => {
            const acc = await conn.getAccountInfo(new solanaWeb3.PublicKey(MINT));
            return acc?.owner?.toBase58?.() || String(acc?.owner || '');
          });
          if (mintOwner) {
            els.mintInfo.style.display = 'block';
            els.mintInfo.textContent = `Mint Program: ${programIdLabel(mintOwner)}`;
          }
        } catch {}
      }

      // ====== 初期化 ======
      function bind() {
        els.connectBtn = document.getElementById('connectWallet');
        els.addr = document.getElementById('walletAddress');
        els.balance = document.getElementById('griBalance');
        els.hint = document.getElementById('hint');
        els.syakeCount = document.getElementById('syakeCount');
        els.umeCount = document.getElementById('umeCount');
        els.mintInfo = document.getElementById('mintInfo');

        updateVoteUI();

        if (typeof solanaWeb3 === 'undefined') {
          console.error('bind: solanaWeb3 is not loaded');
          els.hint.style.display = 'block';
          els.hint.textContent = '内部エラー: Solana web3 ライブラリが読み込まれていません。ネットワークや CSP を確認してください。';
        }

        els.connectBtn?.addEventListener('click', async () => {
          try {
            const conn = await connectPhantom();
            if (!conn) return;
            const { provider, pubkey } = conn;
            els.addr.textContent = `ウォレット: ${pubkey}`;
            els.hint.style.display = 'block';
            els.hint.textContent = '残高読取は複数RPCでフェイルオーバーします（ウォレット側ネットワークは不問）';
            await fetchGRIBalance(pubkey);

            // accountChanged ハンドラを改善: pubkey が来る場合は UI 更新、null の場合は切断扱い
            try {
              provider?.on?.('accountChanged', (newPubkey) => {
                console.log('provider accountChanged', newPubkey);
                if (!newPubkey) {
                  console.log('accountChanged: no pubkey, reloading');
                  return location.reload();
                }
                const pk = (typeof newPubkey?.toString === 'function') ? newPubkey.toString() : String(newPubkey);
                els.addr.textContent = `ウォレット: ${pk}`;
                // 再取得
                fetchGRIBalance(pk).catch((e)=>console.warn('fetchGRIBalance after accountChanged failed', e));
              });

              provider?.on?.('disconnect', () => {
                console.log('provider disconnect');
                els.addr.textContent = 'ウォレット未接続 / Wallet not connected';
                els.balance.textContent = 'GRI 残高: -';
                els.hint.style.display = 'none';
              });
            } catch (e) {
              console.warn('failed to bind provider events', e);
            }
          } catch (e) {
            console.error('connect failed', e);
            alert(`ウォレット接続に失敗: ${e?.message || e}`);
          }
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', bind);
      } else { bind(); }
    })();
  </script>
</body>
</html>
