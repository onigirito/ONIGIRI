<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Title:ONIGIRI コイン</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    body { font-family: "Noto Sans JP", sans-serif; margin: 0; padding: 0; background-color: #f8f8f8; text-align: center; color: #333; }
    header { background-color: #2c3e50; color: white; padding: 15px 0; font-size: 1.5em; }
    main { width: 80%; max-width: 800px; margin: 20px auto; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); }
    img { max-width: 200px; height: auto; margin: 20px; }
    .info { font-size: 1.2em; margin: 10px 0; }
    footer { background-color: #2c3e50; color: white; padding: 10px 0; margin-top: 20px; }
    .vote-container { display: flex; justify-content: center; align-items: center; margin-top: 20px; gap: 24px; flex-wrap: wrap; }
    .vote-item { margin: 0 20px; text-align: center; }
    .vote-button { margin-top: 10px; padding: 10px 20px; font-size: 1em; cursor: pointer; border: none; background-color: #3498db; color: white; border-radius: 10px; transition: background 0.3s; }
    .vote-button:hover { background-color: #2980b9; }
    .wp-link { margin-top: 30px; font-size: 1.2em; }
    .additional-links { margin-top: 20px; text-align: left; display: inline-block; }
    .additional-links a { color: #007BFF; text-decoration: none; font-size: 1em; }
    .additional-links a:hover { text-decoration: underline; }
    .muted { opacity: .75; font-size: .95em; }
    .tiny { opacity: .65; font-size: .85em; }
  </style>
</head>
<body>
  <header>
    <h1> ONIGIRI コイン （GRI）</h1>
  </header>
  <main>
    <img src="onigiri2.png" alt="ONIGIRI コイン" />
    <p class="info"><strong>発行量:</strong> 22m</p>
    <p class="info"><strong>どんな味がお好みですか？ / What flavor do you prefer?</strong></p>

    <div class="vote-container">
      <div class="vote-item">
        <img src="syake.webp" alt="鮭" />
        <button class="vote-button" onclick="vote('syake')">投票する / Vote</button>
        <div>投票数: <span id="syakeCount">0</span></div>
      </div>
      <div class="vote-item">
        <img src="ume.webp" alt="梅干し" />
        <button class="vote-button" onclick="vote('ume')">投票する / Vote</button>
        <div>投票数: <span id="umeCount">0</span></div>
      </div>
    </div>

    <button id="connectWallet" class="vote-button">ウォレットを接続 / Connect Wallet</button>
    <p id="walletAddress">ウォレット未接続 / Wallet not connected</p>
    <p id="griBalance">GRI 残高: -</p>
    <p id="hint" class="muted" style="display:none"></p>
    <p id="mintInfo" class="tiny" style="display:none"></p>

    <div class="wp-link">
      <a href="wp.html" target="_blank">ホワイトペーパーはこちら / View the Whitepaper</a>
    </div>

    <div class="additional-links">
      <p><strong>Solscan:</strong> <a href="https://solscan.io/token/Va7yuUnSYdg23QjHjPAc9fkBrK3oD4mr3Ee52vFcyev" target="_blank">GRI トークン情報</a></p>
      <p><strong>取引所 / Exchanges:</strong></p>
      <ul>
        <li><a href="https://photon-sol.tinyastro.io/en/lp/2WBSLsjagCt3BLncpwBrprFF5uhFz8WbdrpvGvueZ8tz" target="_blank">Photon SOL</a></li>
        <li><a href="https://www.geckoterminal.com/solana/pools/2WBSLsjagCt3BLncpwBrprFF5uhFz8WbdrpvGvueZ8tz" target="_blank">GeckoTerminal</a></li>
      </ul>
    </div>
  </main>
  <footer>
    <p>&copy; 2025 ONIGIRI Coin. All Rights Reserved.</p>
  </footer>

  <!-- 先に web3.js を読み込む -->
  <script src="https://unpkg.com/@solana/web3.js@1.30.0/lib/index.iife.min.js"></script>

  <script>
    (function() {
      // ====== iframe検出 ======
      function isInIframe() {
        try {
          return window.self !== window.top;
        } catch (e) {
          return true;
        }
      }

      function checkIframeAndWarn() {
        if (isInIframe()) {
          console.warn('⚠️ このページはiframe内で表示されています');
          console.warn('⚠️ Phantomウォレットはセキュリティ上の理由でiframe内からの接続をブロックします');
          console.warn('⚠️ 新しいタブで開いてください');

          // 警告を表示
          const warning = document.createElement('div');
          warning.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ff6b6b;
            color: white;
            padding: 15px;
            text-align: center;
            z-index: 10000;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
          `;
          warning.innerHTML = `
            ⚠️ このページはiframe内で表示されているため、ウォレット接続できません<br>
            <button onclick="window.open(window.location.href, '_blank')" style="
              margin-top: 10px;
              padding: 8px 16px;
              background: white;
              color: #ff6b6b;
              border: none;
              border-radius: 5px;
              cursor: pointer;
              font-weight: bold;
            ">新しいタブで開く / Open in New Tab</button>
          `;
          document.body.insertBefore(warning, document.body.firstChild);

          return true;
        }
        return false;
      }

      // ====== 設定 ======
      const MINT = "Va7yuUnSYdg23QjHjPAc9fkBrK3oD4mr3Ee52vFcyev"; // GRI mint
      // 複数の無料公開RPCを試行（制限あり、でもどれかが動く可能性）
      const RPC_URLS = [
        "https://solana-rpc.publicnode.com",
        "https://rpc.hellomoon.io",
        "https://api.mainnet-beta.solana.com"
      ];

      const els = {
        connectBtn: null,
        addr: null,
        balance: null,
        hint: null,
        syakeCount: null,
        umeCount: null,
        mintInfo: null,
      };

      const inIframe = checkIframeAndWarn();

      // ====== Phantom 優先 ======
      function getPhantomProvider() {
        console.log('=== Phantom検出開始 ===');
        console.log('window.phantom:', window.phantom);
        console.log('window.solana:', window.solana);
        console.log('window.phantom?.solana:', window.phantom?.solana);

        // 方法1: window.phantom.solana (推奨)
        if ('phantom' in window) {
          const phantomProvider = window.phantom?.solana;
          console.log('window.phantom.solana found:', phantomProvider);
          if (phantomProvider?.isPhantom) {
            console.log('✓ Phantomプロバイダー検出成功 (window.phantom.solana)');
            console.log('Provider details:', {
              isPhantom: phantomProvider.isPhantom,
              publicKey: phantomProvider.publicKey?.toString(),
              isConnected: phantomProvider.isConnected
            });
            return phantomProvider;
          }
        }

        // 方法2: window.solana
        if ('solana' in window) {
          const provider = window.solana;
          console.log('window.solana found:', provider);
          console.log('window.solana.isPhantom:', provider?.isPhantom);

          if (provider?.isPhantom) {
            console.log('✓ Phantomプロバイダー検出成功 (window.solana)');
            return provider;
          }

          // providers配列から探す
          if (provider?.providers?.length) {
            console.log('複数のプロバイダーが見つかりました:', provider.providers.length);
            const phantom = provider.providers.find((p) => p?.isPhantom);
            if (phantom) {
              console.log('✓ Phantomプロバイダー検出成功 (providers配列)');
              return phantom;
            }
          }
        }

        console.log('✗ Phantomプロバイダーが見つかりませんでした');
        return null;
      }

      // Phantomプロバイダーが利用可能になるまで待機
      async function waitForPhantom(maxAttempts = 10) {
        for (let i = 0; i < maxAttempts; i++) {
          const provider = getPhantomProvider();
          if (provider) return provider;
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        return null;
      }

      // タイムアウト付きPromise
      function withTimeout(promise, ms, errorMsg) {
        return Promise.race([
          promise,
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error(errorMsg)), ms)
          )
        ]);
      }

      async function connectPhantom() {
        // iframe内ではウォレット接続できない
        if (inIframe) {
          console.error('iframe内ではウォレット接続できません');
          alert('⚠️ iframe内ではウォレット接続できません\n\nPhantomウォレットはセキュリティ上の理由で、iframe内からの接続をブロックします。\n\n上部の赤いバーの「新しいタブで開く」ボタンをクリックしてください。\n\n⚠️ Cannot connect wallet in iframe\n\nPhantom wallet blocks connections from iframes for security reasons.\n\nPlease click "Open in New Tab" button in the red bar above.');
          return null;
        }

        // Phantomが読み込まれるまで待つ
        console.log('=== connectPhantom 開始 ===');
        const provider = await waitForPhantom();

        if (!provider) {
          console.error('Phantomプロバイダーが見つかりません');
          alert('Phantom 拡張が見つかりません。\nPhantomをインストールして、ページを再読み込みしてください。\n\nPhantom wallet extension not found.\nPlease install Phantom and reload the page.');
          window.open('https://phantom.app/', '_blank');
          return null;
        }

        console.log('✓ Phantomプロバイダー取得成功');
        console.log('Provider type:', typeof provider);
        console.log('Provider.connect type:', typeof provider.connect);
        console.log('Provider.isConnected:', provider.isConnected);
        console.log('Provider.publicKey:', provider.publicKey?.toString());

        try {
          console.log('provider.connect() を呼び出します...');
          console.log('これからPhantomの接続確認ポップアップが表示されるはずです');

          // 30秒のタイムアウトを設定
          const connectPromise = provider.connect();
          console.log('connect() Promise created:', connectPromise);

          const resp = await withTimeout(
            connectPromise,
            30000,
            'ウォレット接続がタイムアウトしました'
          );

          console.log('connect() レスポンス:', resp);
          console.log('resp.publicKey:', resp?.publicKey);

          const pubkey = resp.publicKey.toString();
          console.log('✓ 接続成功! Public Key:', pubkey);
          return { provider, pubkey };
        } catch (error) {
          console.error('=== 接続エラー発生 ===');
          console.error('エラーオブジェクト:', error);
          console.error('エラーメッセージ:', error?.message);
          console.error('エラーコード:', error?.code);
          console.error('エラースタック:', error?.stack);

          if (error.code === 4001) {
            // ユーザーがリクエストを拒否
            console.log('ユーザーが接続をキャンセルしました');
            alert('接続がキャンセルされました。\nConnection cancelled.');
          } else if (error.message?.includes('timeout') || error.message?.includes('タイムアウト')) {
            console.log('接続がタイムアウトしました');
            alert('ウォレット接続がタイムアウトしました。\nPhantomウォレットが起動しているか確認して、再度お試しください。\n\nConnection timeout.\nPlease make sure Phantom wallet is running and try again.');
          } else if (error.message?.includes('Network request failed')) {
            console.log('ネットワークリクエストエラー');
            alert('接続時にネットワークエラーが発生しました。\n\n考えられる原因：\n• Phantomの接続確認ポップアップが表示されましたか？\n• ブラウザのポップアップブロックを確認してください\n• Phantomウォレットを再起動してください\n• RPCエンドポイントが一時的に利用できない可能性があります\n\n注意: エラーが残高取得時に発生している場合、ウォレット自体は接続されています。\n\nNetwork request failed.\nNote: If error occurs during balance fetch, wallet may be connected.');
          } else {
            console.log('予期しないエラー');
            throw error;
          }
          return null;
        }
      }

      // ====== ユーティリティ ======
      function updateVoteUI() {
        els.syakeCount.textContent = String(Number(localStorage.getItem('vote_syake') || '0'));
        els.umeCount.textContent = String(Number(localStorage.getItem('vote_ume') || '0'));
      }

      window.vote = function(kind) {
        const key = kind === 'syake' ? 'vote_syake' : 'vote_ume';
        const next = (Number(localStorage.getItem(key) || '0') + 1);
        localStorage.setItem(key, String(next));
        updateVoteUI();
      };

      async function withRPCs(fn) {
        let lastErr = null;
        for (const url of RPC_URLS) {
          try {
            console.log(`RPC接続試行: ${url}`);
            if (typeof solanaWeb3 === 'undefined') throw new Error('solanaWeb3 未ロード');
            const c = new solanaWeb3.Connection(url, 'confirmed');

            // 軽く ping（5秒タイムアウトに短縮）
            await withTimeout(c.getEpochInfo(), 5000, 'RPC ping タイムアウト');
            console.log(`✓ RPC接続成功: ${url}`);

            // 実際の処理（20秒タイムアウトに短縮）
            return await withTimeout(fn(c), 20000, 'RPC処理タイムアウト');
          } catch (e) {
            lastErr = e;
            console.warn(`✗ RPC失敗 (${url}):`, e?.message || e);
          }
        }
        console.error('全てのRPCエンドポイントに失敗しました');
        throw lastErr || new Error('全てのRPCに失敗');
      }

      function programIdLabel(pid) {
        const s = String(pid);
        if (s === 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') return 'SPL Token (legacy)';
        if (s === 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb') return 'Token-2022 (extensions)';
        return s;
      }

      // ====== 残高取得（mintフィルタ優先） ======
      async function fetchGRIBalance(ownerBase58) {
        try {
          els.balance.textContent = 'GRI 残高: 読み込み中... / Loading...';

          const owner = new solanaWeb3.PublicKey(ownerBase58);

          const { amountStr, found, program } = await withRPCs(async (conn) => {
            // 1) mint で直接フィルタ（最もシンプル & プログラム差異に強い）
            const parsedByMint = await conn.getParsedTokenAccountsByOwner(owner, { mint: new solanaWeb3.PublicKey(MINT) });
            if (parsedByMint.value?.length) {
              const info = parsedByMint.value[0].account.data.parsed.info;
              const tok = info.tokenAmount;
              const amt = tok.uiAmountString ?? (typeof tok.uiAmount === 'number' ? String(tok.uiAmount) : '0');
              return { amountStr: amt, found: true, program: info.owner || 'unknown' };
            }

            // 2) 念のため programId で両方試す
            const PROGRAM_IDS = [
              'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
              'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'
            ];
            for (const pid of PROGRAM_IDS) {
              const res = await conn.getParsedTokenAccountsByOwner(owner, { programId: new solanaWeb3.PublicKey(pid) });
              for (const entry of res.value) {
                const info = entry.account.data.parsed.info;
                if (info.mint === MINT) {
                  const tok = info.tokenAmount;
                  const amt = tok.uiAmountString ?? (typeof tok.uiAmount === 'number' ? String(tok.uiAmount) : '0');
                  return { amountStr: amt, found: true, program: pid };
                }
              }
            }

            // 3) 見つからない（ATA未作成 or 残高0）
            return { amountStr: '0', found: false, program: null };
          });

          els.balance.textContent = `GRI 残高: ${amountStr} GRI`;
          if (!found) {
            els.hint.style.display = 'block';
            els.hint.textContent = 'GRI のトークン口座が見つかりません（初受取前=ATA未作成の可能性）';
          }

          // Mint の owner (= どのトークンプログラムか) も表示
          try {
            const mintOwner = await withRPCs(async (conn) => {
              const acc = await conn.getAccountInfo(new solanaWeb3.PublicKey(MINT));
              return acc?.owner?.toBase58?.() || String(acc?.owner || '');
            });
            if (mintOwner) {
              els.mintInfo.style.display = 'block';
              els.mintInfo.textContent = `Mint Program: ${programIdLabel(mintOwner)}`;
            }
          } catch {}
        } catch (error) {
          console.error('残高取得エラー:', error);
          els.balance.textContent = 'GRI 残高: 表示できません（ウォレットは接続済み）';
          els.hint.style.display = 'block';
          els.hint.textContent = '✅ ウォレット接続成功！残高表示のみRPC制限で失敗していますが、トランザクションは可能です。Solscanで残高を確認できます: solscan.io/account/[あなたのアドレス] / Wallet connected! Balance display failed due to RPC limits, but transactions work.';
        }
      }

      // ====== 自動接続 ======
      async function tryAutoConnect() {
        // iframe内では自動接続をスキップ
        if (inIframe) {
          console.log('iframe内のため自動接続をスキップします');
          return;
        }

        try {
          console.log('自動接続を試みています...');
          const provider = await waitForPhantom();
          if (!provider) {
            console.log('Phantomプロバイダーが見つかりません');
            return;
          }

          // 既に接続済みの場合は自動接続（タイムアウト10秒）
          const resp = await withTimeout(
            provider.connect({ onlyIfTrusted: true }),
            10000,
            '自動接続タイムアウト'
          );

          if (resp?.publicKey) {
            const pubkey = resp.publicKey.toString();
            console.log('自動接続成功:', pubkey);

            // UIを更新
            els.connectBtn.textContent = '接続済み / Connected';
            els.connectBtn.style.backgroundColor = '#27ae60';
            els.connectBtn.disabled = true;
            els.addr.textContent = `ウォレット: ${pubkey.substring(0, 4)}...${pubkey.substring(pubkey.length - 4)}`;

            // 残高を非同期で取得
            fetchGRIBalance(pubkey).catch(err => {
              console.error('自動接続後の残高取得に失敗:', err);
            });

            // イベントリスナーを設定
            provider?.on?.('accountChanged', (publicKey) => {
              if (publicKey) {
                console.log('Account changed:', publicKey.toString());
                location.reload();
              } else {
                console.log('Account disconnected');
                location.reload();
              }
            });
            provider?.on?.('disconnect', () => {
              console.log('Wallet disconnected');
              location.reload();
            });
          }
        } catch (e) {
          // 自動接続失敗は無視（ユーザーが手動で接続できる）
          // タイムアウトや信頼されていない場合は正常な動作
          if (e?.message?.includes('タイムアウト') || e?.code === 4001) {
            console.log('自動接続スキップ（手動接続が必要）');
          } else {
            console.log('自動接続失敗:', e?.message || e);
          }
        }
      }

      // ====== 初期化 ======
      function bind() {
        els.connectBtn = document.getElementById('connectWallet');
        els.addr = document.getElementById('walletAddress');
        els.balance = document.getElementById('griBalance');
        els.hint = document.getElementById('hint');
        els.syakeCount = document.getElementById('syakeCount');
        els.umeCount = document.getElementById('umeCount');
        els.mintInfo = document.getElementById('mintInfo');

        updateVoteUI();

        // ページロード時に自動接続を試みる
        tryAutoConnect();
        els.connectBtn?.addEventListener('click', async () => {
          // ボタンを無効化して二重クリックを防止
          els.connectBtn.disabled = true;
          els.connectBtn.textContent = '接続中... / Connecting...';

          try {
            const conn = await connectPhantom();
            if (!conn) {
              els.connectBtn.disabled = false;
              els.connectBtn.textContent = 'ウォレットを接続 / Connect Wallet';
              return;
            }

            const { provider, pubkey } = conn;

            // ウォレット接続成功 - すぐにUIを更新
            els.connectBtn.textContent = '接続済み / Connected';
            els.connectBtn.style.backgroundColor = '#27ae60';
            els.addr.textContent = `ウォレット: ${pubkey.substring(0, 4)}...${pubkey.substring(pubkey.length - 4)}`;
            els.hint.style.display = 'block';
            els.hint.textContent = '残高読取は複数RPCでフェイルオーバーします（ウォレット側ネットワークは不問）';

            // 残高を非同期で取得（失敗しても接続は維持）
            fetchGRIBalance(pubkey).catch(err => {
              console.error('残高取得に失敗しましたが、ウォレットは接続されています:', err);
            });

            // ウォレットイベントのリスナーを設定
            provider?.on?.('accountChanged', (publicKey) => {
              if (publicKey) {
                console.log('Account changed to:', publicKey.toString());
                location.reload();
              } else {
                console.log('Account disconnected');
                location.reload();
              }
            });

            provider?.on?.('disconnect', () => {
              console.log('Wallet disconnected');
              location.reload();
            });
          } catch (e) {
            console.error('connect failed', e);
            alert(`ウォレット接続に失敗しました:\n${e?.message || e}\n\nWallet connection failed:\n${e?.message || e}`);
            els.connectBtn.disabled = false;
            els.connectBtn.textContent = 'ウォレットを接続 / Connect Wallet';
          }
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', bind);
      } else { bind(); }
    })();
  </script>
</body>
</html>



